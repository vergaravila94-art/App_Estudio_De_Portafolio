# -*- coding: utf-8 -*-
"""Estudio Portafolio Financiero

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l18_nxHy_ff4kfWdvn6a_CpNPZb-_RYQ
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

st.title("Análisis de Portafolio usando la metodología MV")

import streamlit as st
import pandas as pd

# Selección de empresas
tickers = st.multiselect(
    "Selecciona las empresas (tickers)",
    ["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", "FB", "JPM", "BRK-B", "V", "JNJ"],
    default=["AAPL", "MSFT", "GOOGL"]
)

if tickers:
    # Pesos
    pesos_str = st.text_input("Introduce los pesos del portafolio separados por coma (deben sumar 1)",
                              "0.4,0.4,0.2")
    try:
        pesos = [float(p.strip()) for p in pesos_str.split(",")]
    except:
        st.error("Error en la entrada de pesos. Deben ser números separados por coma.")
        st.stop()

    if len(pesos) != len(tickers):
        st.error("Número de pesos diferente al número de tickers seleccionados.")
        st.stop()

    if abs(sum(pesos) - 1) > 1e-3:
        st.error("Los pesos deben sumar aproximadamente 1.")
        st.stop()

    inversion_inicial = st.number_input("Monto de inversión inicial ($)", min_value=1000, value=10000)

    fecha_inicio = st.date_input("Fecha inicio", pd.to_datetime("2020-01-01"))
    fecha_fin = st.date_input("Fecha fin", pd.to_datetime("2023-01-01"))
    if fecha_inicio >= fecha_fin:
        st.error("Fecha inicio debe ser antes que fecha fin")
        st.stop()

    frecuencia = st.selectbox("Frecuencia", ["1d", "1wk", "1mo"], index=0)
else:
    st.warning("Por favor, selecciona al menos una empresa.")

import yfinance as yf
import streamlit as st
# Descargar datos con yfinance
datos = yf.download(tickers, start=fecha_inicio, end=fecha_fin, interval=frecuencia, auto_adjust=False)["Adj Close"].dropna()
st.subheader("Precios ajustados")
st.line_chart(datos)

# Retornos y retornos acumulados
retornos = datos.pct_change().dropna()
retornos_acum = (1 + retornos).cumprod() - 1

# Retorno del portafolio
ret_portafolio = retornos.dot(pesos)
ret_acum_portafolio = (1 + ret_portafolio).cumprod() - 1

import numpy as np

factor_annualizacion = {"1d": 252, "1wk": 52, "1mo": 12}
volatilidad = ret_portafolio.std() * np.sqrt(factor_annualizacion[frecuencia])

dias_totales = (fecha_fin - fecha_inicio).days
retorno_anualizado = (1 + ret_acum_portafolio.iloc[-1]) ** (252 / dias_totales) - 1

tasa_libre_riesgo = 0.02
sharpe = (retorno_anualizado - tasa_libre_riesgo) / volatilidad if volatilidad != 0 else np.nan

valor_portafolio = inversion_inicial * (1 + ret_acum_portafolio)

st.subheader("Evolución del valor monetario del portafolio")
st.line_chart(valor_portafolio)

st.subheader("Resultados del portafolio")
st.write(f"Retorno anualizado: {retorno_anualizado:.2%}")
st.write(f"Volatilidad anualizada: {volatilidad:.2%}")
st.write(f"Sharpe Ratio: {sharpe:.2f}")

if st.checkbox("Mostrar retornos acumulados por empresa"):
    st.line_chart(retornos_acum)

if st.checkbox("Mostrar diagrama Riesgo vs Retorno"):
    plt.figure(figsize=(8,5))
    volatilidades_emp = retornos.std() * np.sqrt(factor_annualizacion[frecuencia])
    retornos_anualizados_emp = (1 + retornos_acum.iloc[-1]) ** (252 / dias_totales) - 1
    plt.scatter(volatilidades_emp, retornos_anualizados_emp)
    for i, txt in enumerate(tickers):
        plt.annotate(txt, (volatilidades_emp[i], retornos_anualizados_emp[i]))
    plt.xlabel("Volatilidad")
    plt.ylabel("Retorno Anualizado")
    st.pyplot(plt)

if st.checkbox("Mostrar heatmap de correlaciones"):
    plt.figure(figsize=(8,6))
    sns.heatmap(retornos.corr(), annot=True, cmap="coolwarm")
    st.pyplot(plt)

if st.checkbox("Mostrar histograma de retornos del portafolio"):
    plt.figure(figsize=(8,4))
    plt.hist(ret_portafolio, bins=50, alpha=0.7)
    plt.xlabel("Retornos")
    plt.ylabel("Frecuencia")
    st.pyplot(plt)

